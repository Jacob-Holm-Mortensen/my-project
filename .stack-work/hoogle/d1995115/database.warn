base:775:failed to parse: coerce :: Coercible * a b => a -> b
base:833:failed to parse: class (~R#) k k a b => Coercible k (a :: k) (b :: k)
base:3136:failed to parse: instance forall k (a :: k) (b :: k). a ~ b => a ~ b
base:3768:failed to parse: (**, logBase) :: Floating a => a -> a -> a
base:3769:failed to parse: (**, logBase) :: Floating a => a -> a -> a
base:4471:failed to parse: }
base:4483:failed to parse: }
base:11634:failed to parse: type HasCallStack = ?callStack :: CallStack
base:15531:failed to parse: (+, -, *) :: Num a => a -> a -> a
base:15532:failed to parse: (+, -, *) :: Num a => a -> a -> a
base:15533:failed to parse: (+, -, *) :: Num a => a -> a -> a
base:15615:failed to parse: (**, logBase) :: Floating a => a -> a -> a
base:15616:failed to parse: (**, logBase) :: Floating a => a -> a -> a
base:18043:failed to parse: type Type = *
base:18049:failed to parse: type * = *
base:18052:failed to parse: type ★ = *
base:20004:failed to parse: coerce :: Coercible * a b => a -> b
base:20062:failed to parse: class (~R#) k k a b => Coercible k (a :: k) (b :: k)
base:20194:failed to parse: }
ghc:979:failed to parse: class (Typeable * e, Show e) => Exception e
ghc:6447:failed to parse: type LImportDecl name = Located (ImportDecl name)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi'
ghc:6489:failed to parse: type LIE name = Located (IE name)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma'
ghc:13046:failed to parse: }
ghc:15598:failed to parse: }
ghc:15618:failed to parse: }
ghc:23562:failed to parse: type LHsType name = Located (HsType name)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc:23673:failed to parse: type LConDeclField name = Located (ConDeclField name)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc:24251:failed to parse: type LHsDecl id = Located (HsDecl id)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' 
ghc:24281:failed to parse: type HsDeriving name = Maybe (Located [LHsSigType name])  The optional 'deriving' clause of a data declaration  @Nothing@ => not specified, @Just []@ => derive exactly what is asked  It's a 'LHsSigType' because, with Generalised Newtype Deriving, we can mention type variables that aren't bound by the date type.   e.g. data T b = ... deriving( C [a] ) should producd a derived instance for (C [a] (T b))  The payload of the Maybe is Located so that we have a place to hang the API annotations: - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnDeriving', 'ApiAnnotation.AnnOpen','ApiAnnotation.AnnClose'
ghc:24496:failed to parse: type LTyFamInstEqn name = Located (TyFamInstEqn name)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a list
ghc:24499:failed to parse: type HsTyPats name = HsImplicitBndrs name [LHsType name]  Type patterns (with kind and type bndrs) See Note [Family instance declaration binders]
ghc:24667:failed to parse: type LConDecl name = Located (ConDecl name)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a GADT constructor list
ghc:24983:failed to parse: type LHsExpr id = Located (HsExpr id)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc:26847:failed to parse: type AnnPayload = Serialized  The "payload" of an annotation allows recovery of its value at a given type, and can be persisted to an interface file
ghc-prim:219:failed to parse: type * = TYPE PtrRepLifted
ghc-prim:222:failed to parse: type ★ = TYPE PtrRepLifted
haskeline:175:failed to parse: class (Typeable * e, Show e) => Exception e
hoopl:628:failed to parse: }
hoopl:648:failed to parse: }
hoopl:682:failed to parse: }
template-haskell:1221:failed to parse: type Cxt = [Pred]  @(Eq a, Ord b)@
template-haskell:3563:failed to parse: type Cxt = [Pred]  @(Eq a, Ord b)@
